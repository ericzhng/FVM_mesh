# Converting pip/conda Gmsh to MSVC-Compatible Library

This document describes how the Gmsh library in this folder was generated by converting the pip-installed Gmsh module to be compatible with MSVC.

## Background

### Why Not Use Other Options?

| Option | Problem |
|--------|---------|
| **Official Gmsh SDK** | Linking issues with MSVC, missing dependencies |
| **vcpkg Gmsh** | Built with `ENABLE_MESH=OFF` - no mesh generation capability |
| **pip/conda Gmsh** | Compiled with MinGW - ABI incompatible with MSVC |

### The Problem with pip/conda Gmsh

The Gmsh library installed via pip/conda was **cross-compiled from Linux using MinGW (GCC)**, which creates two incompatibilities with MSVC:

1. **C++ ABI incompatibility**: GCC and MSVC use different C++ name mangling schemes
   ```
   GCC exports:  _ZN4gmsh10initializeEiPPcbb
   MSVC expects: ?initialize@gmsh@@YAXHPEAPEAD_N1@Z
   ```

2. **Import library format**: The `.lib` file from pip is in GNU `ar` archive format, not MSVC COFF format

### How I Detected MinGW Compilation

```bash
# Check library format (ar = GNU, COFF = MSVC)
file gmsh.dll.lib
# Output: "current ar archive" (GNU format, not MSVC)

# Check symbol mangling style
gendef gmsh-4.15.dll
grep "gmsh" gmsh-4.15.def | head -5
# Shows GCC-style mangled names like _ZN4gmsh...
```

---

## The Solution

### Overview

Gmsh provides both C++ and C APIs. While the C++ API has compiler-specific name mangling, the **C API uses plain function names** (`gmshInitialize`, `gmshFinalize`) that are compatible across all compilers.

Gmsh also provides `gmsh.h_cwrap` - a C++ header that wraps the C API internally, giving you the familiar C++ interface while using the portable C functions.

### Prerequisites

- **MinGW-w64** with `gendef` and `dlltool` (typically comes with MSYS2 or Git Bash)
- **Python environment** with Gmsh installed: `pip install gmsh`

---

## Step-by-Step Conversion Process

### Step 1: Install Gmsh via pip

```bash
# In your conda/virtual environment
pip install gmsh
```

Locate the installation (example paths):
```
Headers:  C:\Users\<user>\.conda\envs\<env>\include\
Library:  C:\Users\<user>\.conda\envs\<env>\Lib\
```

### Step 2: Copy the C API Wrapper Header

The key file is `gmsh.h_cwrap` which provides C++ syntax but calls C functions internally.

```bash
# Copy and rename the wrapper header
cp <conda_env>/include/gmsh.h_cwrap  extern/gmsh-4.15.0/include/gmsh.h
cp <conda_env>/include/gmshc.h       extern/gmsh-4.15.0/include/gmshc.h
```

### Step 3: Generate MSVC-Compatible Import Library

```bash
cd <conda_env>/Lib

# Extract ALL exports from the DLL
gendef gmsh-4.15.dll
# Creates: gmsh-4.15.def

# Filter to keep ONLY C API functions (plain names, no mangling)
echo 'LIBRARY "gmsh-4.15"' > gmsh_msvc.def
echo 'EXPORTS' >> gmsh_msvc.def
grep "^gmsh[A-Z]" gmsh-4.15.def >> gmsh_msvc.def

# Verify the def file (should show ~383 C API functions)
wc -l gmsh_msvc.def
head -10 gmsh_msvc.def

# Create MSVC-compatible import library using dlltool
dlltool -d gmsh_msvc.def -l gmsh_msvc.lib -D gmsh-4.15.dll -m i386:x86-64
```

### Step 4: Organize Files

Create this folder structure:
```
extern/gmsh-4.15.0/
├── include/
│   ├── gmsh.h          # Renamed from gmsh.h_cwrap (C++ wrapper)
│   └── gmshc.h         # C API declarations
├── lib/
│   ├── gmsh_msvc.lib   # Generated MSVC import library
│   └── gmsh_msvc.def   # Export definitions (for reference)
├── dll/
│   └── gmsh-4.15.dll   # Original DLL from pip
└── readme-gmsh.md      # This file
```

### Step 5: Configure CMake

**cmake/FindGmsh.cmake** should:
- Point to the bundled SDK include/lib/dll paths
- NOT set `INTERFACE_INCLUDE_DIRECTORIES` on the target (to control include order)

**src/CMakeLists.txt** should:
- Add `${Gmsh_INCLUDE_DIR}` with `BEFORE` keyword to ensure it comes before vcpkg
- Add `GMSH_DLL` compile definition
- Link against `Gmsh::Gmsh`

---

## Verification

### Check Import Table

After building, verify the executable imports C API functions (not mangled C++):

```bash
objdump -p FVM_mesh.exe | grep -A 20 "Import Table" | grep gmsh
```

**Good** (C API):
```
gmshInitialize
gmshFinalize
gmshModelAdd
```

**Bad** (C++ mangled - won't work):
```
?initialize@gmsh@@YAXHPEAPEAD_N1@Z
```

### Runtime Test

```bash
# Copy DLL to executable directory
cp extern/gmsh-4.15.0/dll/gmsh-4.15.dll build/src/Release/

# Run
./build/src/Release/FVM_mesh.exe --help
```

---

## Why This Works

```
┌─────────────────────────────────────────────────────────────┐
│  Your C++ Code                                              │
│  gmsh::initialize()  gmsh::model::add()  gmsh::finalize()   │
└─────────────────────┬───────────────────────────────────────┘
                      │ calls (via gmsh.h wrapper)
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  C API (gmshc.h)                                            │
│  gmshInitialize()   gmshModelAdd()      gmshFinalize()      │
│  (plain names - no compiler-specific mangling)              │
└─────────────────────┬───────────────────────────────────────┘
                      │ links via gmsh_msvc.lib
                      ▼
┌─────────────────────────────────────────────────────────────┐
│  gmsh-4.15.dll (compiled with MinGW)                        │
│  Exports C functions with plain names                       │
└─────────────────────────────────────────────────────────────┘
```

The C API functions are exported **without name mangling**, so they have identical symbol names regardless of which compiler built the DLL or the application. The `gmsh.h_cwrap` header provides the familiar C++ interface (`gmsh::initialize()`) but internally calls the C functions (`gmshInitialize()`), bridging the ABI gap.

---

## Troubleshooting

### Error: "Mesh module not compiled"
- You're using vcpkg's Gmsh which has `ENABLE_MESH=OFF`
- Solution: Use the pip-installed Gmsh as described here

### Error: "Entry point not found" (0xC0000139)
- The executable is importing C++ mangled symbols but DLL exports C API
- Check that you're using `gmsh.h_cwrap` (renamed to `gmsh.h`), not the original `gmsh.h`
- Verify vcpkg's `gmsh.h` is not shadowing yours (rename it to `.bak`)

### Linker error: Unresolved external symbols
- The import library format is wrong (GNU vs COFF)
- Regenerate using `dlltool` as shown above

---

## Files Reference

| File | Source | Purpose |
|------|--------|---------|
| `include/gmsh.h` | `gmsh.h_cwrap` from pip | C++ wrapper calling C API |
| `include/gmshc.h` | pip installation | C API function declarations |
| `lib/gmsh_msvc.lib` | Generated with dlltool | MSVC-compatible import library |
| `lib/gmsh_msvc.def` | Generated with gendef + grep | C API export definitions |
| `dll/gmsh-4.15.dll` | pip installation | The actual Gmsh library |

---

*Generated: January 2026*
*Gmsh Version: 4.15.0*
*Target: MSVC (Visual Studio 2022)*
